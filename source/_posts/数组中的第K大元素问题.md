---
title: 滑动窗口、双指针、单调栈和单调队列问题模板
categories:
- [数据结构与算法]

tags: 
- [数据结构与算法]
- [c++]
- [力扣]

---


**问题：** 在未排序的数组中找到第  **k**  个最大的元素。请注意，需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
**约定:** 假设这里数组的长度为 n。
<!--more-->

#方法一：基于快速排序的选择方法
**思路和方法**
可以用快速排序来解决这个问题，先对原数组排序，再返回倒数第K个位置，这样的平均时间复杂度为$O(nlogn)$,但其实我们可以做的更快。
首先回顾快速排序，这是一个典型的分支算法。对数组$a[l...r]$做快速排序的过程：
> - **分解：** 将数组$a[l...r]$ 「划分」 成两个子数组$a[l...q-1]、a[q+1...r]$，使得$a[l...q-1]$中的每个元素都小于a[q]，且a[q]小于等于$a[q+1...r]$中的每个元素。其中，计算下标q也是「划分」过程的一部分。
- **解决：**通过递归调用快速排序，对子数组$a[l...q-1]$和$a[q+1...r]$进行排序。
- **合并：**因为子数组都是原址排序的，所以并不需要进行合并操作，$a[l...r]$已经有序。
- 上文提到的**「划分」**过程是：从子数组 $a[l...r]$中选择任意一个元素 x作为主元，**调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它**，x的最终位置就是q。

由此发现每次经过「划分」操作后，一定可以确定一个元素的最终位置，即x的最终位置为 q，并且保证 $a[l...q-1]$中的每个元素小于等于a[q]，且a[q] 小于等于$a[q+1...r]$中的每个元素。所以只要某次划分的q为倒数第k个下标的时候，就找到了答案。 只关心这一点，至于$a[l...q-1]$和$a[q+1...r]$是否是有序的，不关心。
因此可以改进快速排序算法来解决这个问题：在分解的过程当中，会对子数组进行划分，如果划分得到的q正好就是我们需要的下标，就直接返回a[q]；否则，如果q比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。

我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为n的问题我们都划分成1和$n - 1$，每次递归的时候又向$n - 1$的集合中递归，这种情况是最坏的，时间代价是 $O(n ^ 2)$。这里可以引入随机化来加速这个过程，它的时间代价的期望是$O(n)$，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。


``` 
inline int partition(vector<int>& a, int l, int r) {
     // 3. 在调用当前方法的randomPartition方法中，已经确定了了随机数是a[r]
    int x = a[r], i = l - 1;
     // 首先比较区间在[l， r]之间， 所以a[j]中的    l<= j <= r
    for (int j = l; j < r; ++j) {
         // 4. a[j] 跟随机数 x 比较, 小于x的数都跟[l,r]左边区间交换，i=l-1,所以++i=l,初始索引就是l,
        if (a[j] <= x) {
            swap(a[++i], a[j]);  //两两交换
        }
    }// 这个for循环操作就是将小于 x 的数都往[i, j]的左边区间设置，从而实现存在[l, i]区间,使得对应数值都 小于 x
    
     //5. 既然已经将<x的值都放在一边了，现在将x也就是a[r] 跟a[i+1]交换，从而分成两个区间[l.i+1]左, [i+2, r]右，左边区间的值都小于x
    swap(a[i + 1], a[r]);
    // 然后返回这个分区值
    return i + 1;
}

inline int randomPartition(vector<int>& a, int l, int r) {
    // 1. 随机数范围: [0, r-l+1) 同时加l, 则是 [l, r+1) = [l, r] 也就是在这个[l,r] 中随机选一个索引出来
    int i = rand() % (r - l + 1) + l;
    
     // 2. 交换a[i]， a[r], 也就是将随机数先放在[l,r]最右边a[r]上
    swap(a[i], a[r]);
    return partition(a, l, r);
}

 // 得到分区值索引q
int quickSelect(vector<int>& a, int l, int r, int index) {
    int q = randomPartition(a, l, r);
    // 如果刚好索引q就是想要的索引，则直接返回
    if (q == index) {
        return a[q];
    } else {
         // 如果不是，比较q 与 index ,确定下次要检索的区间, 要么是[q+1, right], 要么就是[left, q-1]
        return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);
}

 // 要找到的元素所在索引:  前K大，即倒数索引第K个
int findKthLargest(vector<int>& nums, int k) {
    srand(time(0));
    return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);
}

```
**复杂度分析**

> - 时间复杂度:$O(n)$，如上文所述，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。
- 空间复杂度:$O(logn)$，递归使用栈空间的空间代价的期望为$O(logn)$。

**库函数**
> nth_element(first, nth, last, compare)

求[first, last]这个区间中第n大小的元素，如果参数加入了compare函数，就按compare函数的方式比较。nth_element仅排序第n个元素（从0开始索引），即将位置n（从0开始）的元素放在第n大的位置，处理完之后，默认排在它前面的元素都不比它大，排在它后面的元素都不比它小。


---
#方法二：基于堆排序的选择方法
**思路和算法**

也可以使用堆排序来解决这个问题——建立一个大根堆，做$k - 1$次删除操作后堆顶元素就是我们要找的答案。在很多语言中，都有优先队列或者堆的的容器可以直接使用，但是在面试中，面试官更倾向于让更面试者自己实现一个堆。所以这里实现大根堆，主要搞懂「建堆」、「调整」和「删除」的过程。
##**堆**
堆是一种特殊的树结构，即完全二叉树。堆分为大根堆和小根堆，大根堆为根节点的值大于两个子节点的值；小根堆为根节点的值小于两个子节点的值，同时根节点的两个子树也分别是一个堆。

通俗来讲，**二叉树在按层序遍历时在遇到第一个NULL指针即作为结尾的二叉树**就可以称之为完全二叉树。

根节点下标为0，若父节点相应数组下标为i，则其左孩子相应数组下标为2*i+1，右孩子为2*i+2.

**注意：如果我们现在处理第i个序号的结点的数，那么他的父结点序号就是$(i-1)/2$，它的孩子结点就为$2i+1$与$2i+2$。这个容易想，右子节点如果直接除以2，得到$i+1$，但是$2i+2-1$和$2i+1-1$除以2可以得到i。根节点从0开始，则n个节点的堆，最后一个叶节点的下标为$n-1$，其父节点是第一个非叶节点，下标为$((n-1)-1 )/ 2 = (n-2)/2 = n/2 - 1$**



> 1. 首先用前n个元素的无序序列，构建成大顶堆；构建大顶堆时，从最后一个非叶节点$n/2-1$的位置开始检查节点与其孩子值是否满足大顶堆的要求，不满足则需要调整该元素与其孩子节点元素的位置，如果有调整，则调整过的孩子节点（子树）也要递归调用调整子树中的元素值位置，保证子树也是大顶堆。然后按照层次遍历的顺序依次往前，从右到左，从下到上调整所有非叶节点的值，最后根节点的值就是最大值；
2. 得到大顶堆后将根节点与数组待排序部分的最后一个元素交换位置，即将最大元素"沉"到数组末端；
3. 交换过后待排序数组长度减一，再对新长度的待排序数组重复上述过程，直到整个数组排序完成。如果我们要数组整体递增有序，则每次构建的是大顶堆；如果我们要数组整体递减有序，则每次构建的是小顶堆。

```
void buildMaxHeap(vector<int>& A, int n)  //建立最大堆

{
// 从最后一个非叶子节点（n/2-1）开始自底向上构建，
    for(int i = n/2-1; i>=0; --i)  //从（n/2-1）调用一次maxHeapIfy就可以得到最大堆

         maxHeapify(A, i, n);

}


void maxHeapify(vector<int> &A, int i, int n) //将i节点为根的堆中小的数依次上移,n表示堆中的数据个数
{
    int left = 2*i+1;  //i的左儿子
    int right = 2*i+2;  //i的右儿子
    int largest = i;     //先设置父节点和子节点三个节点中最大值的位置为父节点下标
    if(left < n && A[left] > A[largest]){
        largest = left;
    }
    if(right < n && A[right] > A[largest]){
        largest = right;
    }
    if(largest != i){ //最大值不是父节点，交换
        swap(A[i], A[largest]);
        maxHeapify(A, largest, n); //递归调用，保证子树也是最大堆
    }
}

void heapSort(vector<int>& A, int n){   // 堆排序算法
    buildMaxHeap(A,n);  //先建立堆
    for(int i = n-1; i>0; --i){
        // 将根节点(最大值)与数组待排序部分的最后一个元素交换,这样最终得到的是递增序列
        swap(A[0], A[i]);
        // 待排序数组长度减一,只要对换到根节点的元素进行排序，将它下沉就好了。
        maxHeapify(A, 0, i);
    }
}

int findKthLargest(vector<int>& nums, int k) {
    int heapSize = nums.size();
    buildMaxHeap(nums, heapSize);
    for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {
        swap(nums[0], nums[i]);
        --heapSize;
        maxHeapify(nums, 0, heapSize);
    }
    return nums[0];
}

```

**复杂度分析**

> - 时间复杂度$O(nlogn)$，建堆的时间代价是 $O(n)$，删除的总代价是 $O(klogn)$，因为$k < n$，故渐进时间复杂为 $O(n+klogn)=O(nlogn)$。
- 空间复杂度：$O(logn)$，即递归使用栈空间的空间代价。


## **优先级队列**
> priority_queue&lt;Type, Container, Functional&gt;

Type为数据类型， Container为保存数据的容器，Functional为元素比较方式。

如果不写后两个参数，那么容器默认用的是vector，比较方式默认用operator<，也就是优先队列是**大根堆**，队头元素最大。

小根堆用greater &lt;Type&gt;函数，下面是小根堆的例子
```
priority_queue<int, vector<int>, greater<int> > p;
```

堆排序中，用优先级队列涉及到了自定义排序的问题，这里展示了两种写法：

> - 使用 lambda表达式 + decltype
- 使用 struct + 重载操作符()


```
//lambda表达式
auto cmp = [捕获列表](参数列表) -> 返回类型{ 函数体};  
priority_queue<Type, Container, decltype(cmp)> pq(cmp);

//结构体，重载操作符()
struct cmp{
     bool operator()(参数列表) {
            return ;
        }
}

```






